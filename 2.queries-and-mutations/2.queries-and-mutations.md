# 들어가기 전에
- 이 포스팅은 https://graphql.org/learn/queries/ 에 있는 포스팅들을 번역한 것입니다. 오역이나 의역이 있을 수 있습니다. 지적해주시면 확인 후 바로 정정하겠습니다.

- original source of this posting is from https://graphql.org/learn/queries/ If the original author requests deletion, it will be deleted immediately.

- Translated by Jake Seo (서진규)

	- https://velog.io/@jakeseo_me
	- https://github.com/n00nietzsche

> All about GraphQL #2, Queries와 Mutations

# Queries and Mutations
이 페이지에서는 GraphQL 서버에 어떻게 쿼리를 날리는지 상세히 배워볼 것입니다.

## 필드
최대한 간단하게, GraphQL은 객체의 특정한 필드에 대해 묻습니다. 매우 간단한 쿼리와 결과를 실행시켜보며 시작해봅시다.

> 요청
```graphql
{
  hero {
    name
  }
}
```

> 응답
```graphql
{
  "data": {
    "hero" : {
      "name": "R2-D2"
    }
  }
}
```

요청과 결과 쿼리를 보자마자 바로 알 수 있는 것은 둘의 모양이 똑같다는 것입니다. 이건 GraphQL에서는 매우 중요한 사실입니다. 왜냐하면 언제나 예상했던 결과를 받고 서버는 클라이언트가 요청했던게 무엇인지 정확히 알 수 있으니까요.

`name` 필드는 `String` 타입을 반환합니다. 위에서는 스타워즈의 메인 히어로 이름, `"R2-D2"`가 나왔네요.

> 오, 한가지 더 알아두어야 할 것은 위의 쿼리가 상호작용한다(interactive)는 것입니다. 이 의미는 원하는대로 바꾸고 새로운 결과를 받을 수 있다는 것입니다. `appearsIn`이라는 필드를 쿼리 내부에서 `hero` 객체에 추가해보세요 그리고 새로운 결과를 받아보세요.

이전 예제에서, 우리는 문자열 타입인 히어로의 이름만을 질의했습니다. 하지만 필드들도 역시 객체를 참조할 수 있습니다. 그 경우에는, 그 객체에 대한 *sub-selection*을 만들 수 있습니다. GraphQL 쿼리는 관련된 객체들을 탐색(traverse) 할 수 있습니다. 클라이언트가 전형적인 REST 구조처럼 몇번이나 왕복하지 않고 한 번의 요청으로 관련된 많은 데이터를 가져오도록(fetch) 해봅시다.

> 요청
```graphql
{
  hero {
    name
    # Queries can have comments!
    friends {
      name
    }
  }
}
```

> 응답
```graphql
{
  "data": {
    "hero": {
      "name": "R2-D2",
      "friends": [
        {
          "name": "Luke Skywalker"
        },
        {
          "name": "Han Solo"
        }
      ]
    }
  }
}
```

## 인자(Arguments)
만일 우리가 할 수 있는 것이 객체와 필드를 탐색(traverse)하는 것이라면, GraphQL은 데이터를 가져오는데만 매우 유용한 언어였을 것입니다. 하지만 필드로 인자를 넘기는 능력까지 추가하면, 더욱 재밌어집니다.

> 요청
```graphql
{
  human(id: "1000") {
    name
    height
  }
}
```

> 응답
```graphql
{
  "data": {
    "human": {
      "name": Luke Skywalker",
      "height": 1.72
    }
  }
}
```

REST같은 시스템에서는, 오직 한 세트의 인자밖에 넘기지 못했습니다. 쿼리 파라미터와 URL 세그먼트`(역자 주 : URL 뒤에 붙어있는 주소같은 것들..)`만 넘길 수 있었죠. 하지만 GraphQL에서는, 모든 필드와 중첩된(nested) 객체가 인자로 들어갈 수 있습니다. 다중 API fetch 부분을 만들기 위해서 앞으로는 GraphQL을 써보세요. 심지어는 모든 클라이언트를 구현하는 대신 서버에서 단 한번 데이터 트렌스포메이션을 구현하기 위해, 인자를 scalar 필드로 넘길 수도 있습니다.

> 요청
```graphql
{
  human(id: "1000") {
    name
    height(unit: FOOT)
  }
}
```

> 응답
```graphql
{
  "data": {
    "human": {
      "name": "Luke Skywalker",
      "height": 5.6430448
    }
  }
}
```

인자는 많은 다른 타입이 될 수 있습니다. 위의 예제에서, 우리는 유한적인 옵션의 셋을 보여주는 Enumeration 타입을 사용했습니다. 위의 경우에는 length의 유닛들 `METER` 또는 `FOOT`이 있었습니다. GraphQL은 기본으로 제공하는 타입 값들을 갖고 있지만 GraphQL 서버에서 새로운 커스텀 타입들을 정의할 수 있습니다. 단, 전송형으로 직렬화된다면 가능합니다.

# 별칭(Aliases)
만일 날카로운 눈을 가졌다면, 아마 눈치챘을 것입니다. 결과 오브젝트의 필드가 쿼리와 같지만 인자는 포함되어있지 않다는 것을요. 그래서 직접적으로 다른 인자를 이용하여 같은 필드에 데이터를 요청할 수는 없습니다. 이 때문에 별칭(alias)이 필요합니다. 별칭은 결과의 필드 이름을 당신이 원하는대로 만들어줍니다.

> 요청
```graphql
{
  empireHero: hero(episode: EMPIRE) {
    name
  }
  jediHero: hero(episode:JEDI) {
    name
  }
}
```

> 응답
```graphql
{
  "empireHero": {
    "name" : "Luke Skywalker"
  }
  jediHero: {
    "name" : "R2-D2"
  }
}
```

